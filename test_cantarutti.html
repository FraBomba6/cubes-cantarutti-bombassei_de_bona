<html>
	<head>
		<title>Starting Code for 1st Project 2017 - with lights and textures</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
			document.body.appendChild( renderer.domElement );
			
			camera.position.set(10,40,50);
			camera.lookAt( new THREE.Vector3(0,0,0));

			const loader = new THREE.TextureLoader();
			
			// The whole inner pyramid grave object
			var grave = new THREE.Object3D()
			grave.position.set(0,0,0)
			
			/**
			 * 
			 * OUTSIDE WALLS
			 * 
			 */
			function buildWall(x,y,z,dir){
				let pivot = new THREE.Object3D();
				pivot.position.set(x,y,z)
				let increasePositionHor = 0;
				let increasePositionVer = 0;
				for(var i=0; i<6; i++){
					for(var j=0; j<=8; j++){
						let cube = new THREE.Mesh(geometry, material)
						pivot.add(cube)
						if(dir == "ver"){
							cube.position.z = increasePositionHor
						}else{
							cube.position.x = increasePositionHor
						}
						cube.position.y = increasePositionVer
						increasePositionHor += 2
					}
					increasePositionHor = 0
					increasePositionVer += 2
				}
				return pivot
			}

			var texture_grave = loader.load("textures/hiero.jpg")
			var geometry = new THREE.BoxBufferGeometry(2,2,2);
			var material = new THREE.MeshPhongMaterial({
				map: texture_grave
			})

			var innerBuilding = new THREE.Object3D();
			var wall1 = buildWall(0,0,0, "ver")
			var wall2 = buildWall(0,0,0, "hor")
			var wall3 = buildWall(16,0,0, "ver")
			var wall4 = buildWall(0,0,16, "hor")
			innerBuilding.add(wall1)
			innerBuilding.add(wall2)
			innerBuilding.add(wall3)
			grave.add(innerBuilding)

			// Making cubes cast shadows
			innerBuilding.traverseVisible((wall => {
				wall.castShadow = true
				wall.receiveShadow = true
				wall.traverseVisible((cube => {
					cube.castShadow = true
					cube.receiveShadow = true
				}))
			}))

			/**
			 * 
			 * FLOOR OF THE GRAVE
			 * 
			**/

			innerBuilding.position.set(3,2,3)
			var texture_floor = loader.load("textures/grave_wall.jpg")
			var ground = new THREE.Object3D()

			for(var i=0; i<=22; i+=2){
				for(var j=0; j<=23; j+=2){
					var geometry = new THREE.BoxBufferGeometry(2,2,2);
					var material = new THREE.MeshPhongMaterial({
						map: texture_floor
					})
					var cube = new THREE.Mesh(geometry, material)
					cube.position.x = i
					cube.position.z = j
					ground.add(cube)
				}
			}

			grave.add(ground)
			ground.castShadow = true
			ground.receiveShadow = true
			ground.position.set(0,0,0)
			ground.traverseVisible((cube =>{
				cube.castShadow = true
				cube.receiveShadow = true
			}))

			scene.add(grave)
			

			/**
			 * 
			 * SARCOPHAGUS
			 * 
			 */

			var sarcophagus = new THREE.Object3D()
			var texture_sarcophagus = loader.load("textures/sarc.jpg")
			texture_sarcophagus.repeat.set( 1, 1 );
			var geometry_sarcophagus = new THREE.BoxBufferGeometry(1,1,1)
			var material_sarcophagus = new THREE.MeshPhongMaterial({
				color: 0x111111,
				map: texture_sarcophagus
			})
			var material_base_sarcophagus = new THREE.MeshPhongMaterial({
				color: 0x111111
			})

				// SARCOPHAGUS Base
			for(var i=0; i<4; i++){
				for(var j=0; j<8; j++){
					if(i!=0){
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
					}else{
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
					}
					
					sarcophagus.add(sarc)
					sarc.position.set(i,0,j)
				}
			}

				// SARCOPHAGUS  Wall1
			for(var i=0; i<4; i++){
				for(var j=0; j<3; j++){
					if(j!=0){
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
					}else{
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
					}
					sarcophagus.add(sarc)
					sarc.position.set(i,j,0)
				}
			}

				// SARCOPHAGUS Wall2
			for(var i=0; i<8; i++){
				for(var j=0; j<3; j++){
					if(j!=0){
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
					}else{
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
					}
					sarcophagus.add(sarc)
					sarc.position.set(0,j,i)
				}
			}

			// SARCOPHAGUS Wall3
			for(var i=0; i<4; i++){
				for(var j=0; j<3; j++){
					if(j!=0){
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
					}else{
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
					}
					sarcophagus.add(sarc)
					sarc.position.set(i,j,8)
				}
			}

			
			// SARCOPHAGUS Wall4
			for(var i=0; i<=8; i++){
				for(var j=0; j<3; j++){
					if(j!=0){
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
					}else{
						var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
					}
					sarcophagus.add(sarc)
					sarc.position.set(4,j,i)
				}
			}


			grave.add(sarcophagus)
			sarcophagus.position.set(9,1.5,8)


			/**
			 * 
			 * DECORATIONS
			 * 
			 */

			var pharaoh_head_texture = loader.load("textures/pharaoh1test.jpg")
			var monument_texture = loader.load("textures/gravestuff.jpg")
			var pharaoh_geometry = new THREE.BoxBufferGeometry(2,2,2)
			var pharaoh_head_material = new THREE.MeshPhongMaterial({
				color: 0xffffff,
				map: pharaoh_head_texture
			})
			var momument_geometry = new THREE.BoxBufferGeometry(3,3,3)
			var monument_material = new THREE.MeshPhongMaterial({
				color: 0xffffff,
				map: monument_texture
			})
			var pharaoh_head = new THREE.Mesh(pharaoh_geometry, pharaoh_head_material)
			var monument = new THREE.Mesh(momument_geometry, monument_material)
			
			sarcophagus.add(pharaoh_head)
			pharaoh_head.position.set(2,4,-4.8)
			
			//TODO monument

			sarcophagus.add(monument)
			monument.position.set(-2,4,4)


			/**
			 * 
			 * INNER LIGHTS (with torch)
			 * 
			 */

			var geometry_torch = new THREE.BoxBufferGeometry(0.2,0.2,0.2)
			var material_torch = new THREE.MeshPhongMaterial({
				color: 0x111111
			})

			var offset = 5
			for(var i=0; i<6; i++){
				var torch = new THREE.Mesh(geometry_torch, material_torch)
				sarcophagus.add(torch)
				torch.position.set(2,offset+0.4,-3.9)
				offset += 0.2	
			}

			var torch_fire = new THREE.MeshPhongMaterial({
				emissive: 0xfdcf58
			})
			var torch_fire_geom = new THREE.BoxBufferGeometry(0.3,0.3,0.3)
			var torch_light = new THREE.Mesh(torch_fire_geom, torch_fire)
			sarcophagus.add(torch_light)
			torch_light.position.set(2,offset+0.4,-3.85)

			var pointLight1 = new THREE.PointLight(0xf07f13,0.5)
			grave.add(pointLight1)
			pointLight1.position.set(11,8,5)

			var pointLight2 = new THREE.PointLight(0xf07f13,0.1)
			grave.add(pointLight2)
			pointLight2.position.set(5,8,12)

			var pointLight3 = new THREE.PointLight(0xf07f13,0.1)
			grave.add(pointLight3)
			pointLight3.position.set(17,8,12)

			// const pointLightHelper1 = new THREE.PointLightHelper( pointLight1, 1 );
			// scene.add( pointLightHelper1 );
			// const pointLightHelper2 = new THREE.PointLightHelper( pointLight2, 1 );
			// scene.add( pointLightHelper2 );
			// const pointLightHelper3 = new THREE.PointLightHelper( pointLight3, 1 );
			// scene.add( pointLightHelper3 );

			
			var ambientLight = new THREE.AmbientLight(0xcccccc, 0.05)
			grave.add(ambientLight)


			/**
			 * 
			 * SCENE GROUND
			 * 
			 */
			var ground_texture = loader.load("textures/sand.jpg")
			ground_texture.wrapS = THREE.RepeatWrapping;
			ground_texture.wrapT = THREE.RepeatWrapping;
			ground_texture.repeat.set( 512, 512 );
			var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
			var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505, map: ground_texture } );
			//groundMat.color.setHSL( 0.095, 1, 0.75 );
			var ground = new THREE.Mesh( groundGeo, groundMat );
			ground.position.y = -1;
			ground.rotation.x = -Math.PI/2;
			scene.add( ground );
			ground.receiveShadow = true;
			

			// LIGHT

			// var point = new THREE.Object3D()
			// scene.add(point)
			// point.position.set(12,0,0)

			// hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
			// hemiLight.color.setHSL( 0.6, 1, 0.6 );
			// hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			// hemiLight.position.set( 0, 400, 0 );
			// scene.add( hemiLight );

			// dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			// dirLight.color.setHSL( 0.1, 1, 0.95 );
			// dirLight.position.set( 12, 60, 75);
			// dirLight.position.multiplyScalar( 50 );
			// scene.add( dirLight );
			// dirLight.castShadow = true;
			// dirLight.shadow.mapSize.width = 1024;
			// dirLight.shadow.mapSize.height = 1024;
			// const d = 40;

			// dirLight.shadow.camera.left = - d;
			// dirLight.shadow.camera.right = d;
			// dirLight.shadow.camera.top = d;
			// dirLight.shadow.camera.bottom = - d;
			// dirLight.target = point


			// // STATS
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			

			// HELPERS
			//Coordinates.drawAllAxes();
			//const dirLightHelper = new THREE.CameraHelper( dirLight.shadow.camera );
			//scene.add( dirLightHelper );	
			// const hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
			// scene.add( hemiLightHelper );

			// CONTROLS
			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );	
		}
		
		function Update() {
			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}
		
		function Render() {
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>