<html>
<head>
    <title>Starting Code for 1st Project 2017 - with lights and textures</title>
    <style>

        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

    </style>
    <script src="lib/three.min.js"></script>
    <script src="lib/stats.min.js"></script>
    <script src="lib/Coordinates.js"></script>
    <script src="lib/OrbitControls.js"></script>
    <script src="lib/BufferGeometryUtils.js"></script>
    <script src="lib/dat.gui.min.js"></script>
</head>
<body>
<script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

			}

		</script>

<script>

    var scene, camera, renderer, controls, stats;
    var count = 0
    var top_pyramid = []
    var showStatic = true
    animationOn = false
    var params = {
        toggleAnimation: toggleAnimation
    }
    const gui = new dat.gui.GUI({name: "Controls"})
    gui.add( params, 'toggleAnimation', true).name( "Pyramid" );

    function toggleAnimation(){
        showStatic = false
        animationOn = !animationOn
    }

    function Start() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color().setHSL( 0.6, 0, 1 );
        scene.fog = new THREE.Fog( scene.background, 1, 5000 );
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

        renderer = new THREE.WebGLRenderer( {antialias: true} );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.gammaInput = true;
        renderer.gammaOutput = true;
        renderer.shadowMap.enabled = true;
        document.body.appendChild( renderer.domElement );

        camera.position.set(10,40,50);
        camera.lookAt( new THREE.Vector3(0,0,0));

        const loader = new THREE.TextureLoader();

        hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
        hemiLight.color.setHSL( 0.6, 1, 0.6 );
        hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
        hemiLight.position.set( 0, 500, 0 );
        scene.add( hemiLight );

        dirLight = new THREE.PointLight( 0xffffff, 1 );
        dirLight.color.setHSL( 0.1, 1, 0.95 );
        dirLight.position.set( 12, 30, 75);
        scene.add( dirLight );
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;

        const d = 40;

        dirLight.shadow.camera.left = - d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = - d;

        // GROUND
        var ground_size = 500
        var map = loader.load('textures/Ground033_2K_Color.jpg')
        map.wrapS = THREE.RepeatWrapping;
        map.wrapT = THREE.RepeatWrapping;
        map.repeat.set( ground_size/7, ground_size/7 );
        var ao = loader.load('textures/Ground033_2K_AmbientOcclusion.jpg')
        ao.wrapS = THREE.RepeatWrapping;
        ao.wrapT = THREE.RepeatWrapping;
        ao.repeat.set( ground_size/7, ground_size/7 );
        var normal = loader.load('textures/Ground033_2K_Normal.jpg')
        normal.wrapS = THREE.RepeatWrapping;
        normal.wrapT = THREE.RepeatWrapping;
        normal.repeat.set( ground_size/7, ground_size/7 );
        var groundGeo = new THREE.PlaneBufferGeometry( ground_size, ground_size );
        var groundMat = new THREE.MeshPhongMaterial( {
            map: map,
            aoMap: ao,
            normalMap: normal,
            shininess: 0
        } );
        var ground = new THREE.Mesh( groundGeo, groundMat );
        ground.rotation.x = -Math.PI/2;
        scene.add( ground );
        ground.receiveShadow = true;
        ground.castShadow = true;

        // DOME
        const vertexShader = document.getElementById( 'vertexShader' ).textContent;
        const fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
        const uniforms = {
            "topColor": { value: new THREE.Color( 0x0077ff ) },
            "bottomColor": { value: new THREE.Color( 0xffffff ) },
            "offset": { value: 33 },
            "exponent": { value: 0.6 }
        };
        uniforms[ "topColor" ].value.copy( hemiLight.color );

        scene.fog.color.copy( uniforms[ "bottomColor" ].value );

        const skyGeo = new THREE.SphereBufferGeometry(ground_size/2, 32, 15 );
        const skyMat = new THREE.ShaderMaterial( {
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.BackSide
        } );


        const sky = new THREE.Mesh( skyGeo, skyMat );
        scene.add( sky );

        // BRICK and PYRAMID
        var brick_size = 1
        var room_width = 14
        var pyramid_width = 3 * room_width + 2
        var pyramid_height = 3 * room_width / 2 + 1
        var brick_geometry = new THREE.BoxBufferGeometry(brick_size, brick_size, brick_size);
        var brick_material = new THREE.MeshPhongMaterial( {
                map: loader.load('textures/Rock004_2K_Color.jpg'),
                aoMap: loader.load('textures/Rock004_2K_AmbientOcclusion.jpg'),
                normalMap: loader.load('textures/Rock004_2K_Normal.jpg')
            } )

        var pyramid = new THREE.Object3D()
        var bricks = []
        var floor_width, geometry, translation_matrix
        for(var height = 0; height <= room_width - 2; height++){
            floor_width = pyramid_width - 2 * height
            for(var floor_perimeter = 0; floor_perimeter < floor_width * 4 - 4; floor_perimeter++){
                geometry = brick_geometry.clone()
                if(floor_perimeter < floor_width){
                    translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation(floor_perimeter - floor_width/2 + brick_size/2, height + brick_size/2, floor_width/2 - brick_size/2)
                    geometry.applyMatrix(translation_matrix)
                }
                else if(floor_perimeter >= floor_width && floor_perimeter < floor_width * 2 - 1){
                    translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation(floor_width/2 - brick_size/2, height + brick_size/2, floor_width/2 - brick_size/2 - floor_perimeter + floor_width - 1)
                    geometry.applyMatrix(translation_matrix)
                }
                else if(floor_perimeter >= floor_width * 2 - 1 && floor_perimeter < floor_width * 3 - 2){
                    translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation(floor_perimeter - floor_width*2 + 1 - floor_width/2 + brick_size/2, height + brick_size/2, - floor_width/2 + brick_size/2)
                    geometry.applyMatrix(translation_matrix)
                }
                else{
                    translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation( - floor_width/2 + brick_size/2, height + brick_size/2, floor_width/2 - brick_size/2 - floor_perimeter + floor_width * 3 - 3)
                    geometry.applyMatrix(translation_matrix)
                }
                bricks.push(geometry)
            }
        }
        var geometriesBricks = THREE.BufferGeometryUtils.mergeBufferGeometries(bricks);
        var truncated_pyramid = new THREE.Mesh(geometriesBricks, brick_material)
        truncated_pyramid.castShadow=true
        truncated_pyramid.receiveShadow=true
        pyramid.add(truncated_pyramid)
        scene.add(pyramid)

        var south_face = []
        var east_face = []
        var north_face = []
        var west_face = []
        for(var height = room_width - 1; height < pyramid_height ; height++){
            var floor_width = pyramid_width - 2 * height
            for(var floor_perimeter = 0; floor_perimeter < floor_width * 4 - 4; floor_perimeter++){
                geometry = brick_geometry.clone()
                if(floor_perimeter < floor_width){
                    var translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation(floor_perimeter - floor_width/2 + brick_size/2, height + brick_size/2, floor_width/2 - brick_size/2)
                    geometry.applyMatrix(translation_matrix)
                    south_face.push(geometry)
                }
                else if(floor_perimeter >= floor_width && floor_perimeter < floor_width * 2 - 1){
                    var translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation(floor_width/2 - brick_size/2, height + brick_size/2, floor_width/2 - brick_size/2 - floor_perimeter + floor_width - 1)
                    geometry.applyMatrix(translation_matrix)
                    east_face.push(geometry)
                }
                else if(floor_perimeter >= floor_width * 2 - 1 && floor_perimeter < floor_width * 3 - 2){
                    var translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation(floor_perimeter - floor_width*2 + 1 - floor_width/2 + brick_size/2, height + brick_size/2, - floor_width/2 + brick_size/2)
                    geometry.applyMatrix(translation_matrix)
                    north_face.push(geometry)
                }
                else {
                    translation_matrix.makeTranslation(-floor_width / 2 + brick_size / 2, height + brick_size / 2, floor_width / 2 - brick_size / 2 - floor_perimeter + floor_width * 3 - 3)
                    geometry.applyMatrix(translation_matrix)
                    west_face.push(geometry)
                }
            }
        }
        var faces = [south_face, east_face, north_face, west_face]
        faces.forEach(face => {
            geometriesBricks = THREE.BufferGeometryUtils.mergeBufferGeometries(face)
            var mesh = new THREE.Mesh(geometriesBricks, brick_material)
            mesh.castShadow = true
            mesh.receiveShadow = true
            pyramid.add(mesh)
        })


        // The whole inner pyramid grave object
        var grave = new THREE.Object3D()
        grave.position.set(-11, 0, -11)
        /**
         *
         * OUTSIDE WALLS
         *
         */
        function buildWall(x,y,z,dir){
            let pivot = new THREE.Object3D();
            pivot.position.set(x,y,z)
            let increasePositionHor = 0;
            let increasePositionVer = 0;
            for(var i=0; i<6; i++){
                for(var j=0; j<=8; j++){
                    let cube = new THREE.Mesh(geometry, material)
                    pivot.add(cube)
                    if(dir == "ver"){
                        cube.position.z = increasePositionHor
                    }else{
                        cube.position.x = increasePositionHor
                    }
                    cube.position.y = increasePositionVer
                    increasePositionHor += 2
                }
                increasePositionHor = 0
                increasePositionVer += 2
            }
            return pivot
        }

        var texture_grave = loader.load("textures/hiero.jpg")
        var geometry = new THREE.BoxBufferGeometry(2,2,2);
        var material = new THREE.MeshPhongMaterial({
            map: texture_grave
        })

        var innerBuilding = new THREE.Object3D();
        var wall1 = buildWall(0,0,0, "ver")
        var wall2 = buildWall(0,0,0, "hor")
        var wall3 = buildWall(16,0,0, "ver")
        var wall4 = buildWall(0,0,16, "hor")
        innerBuilding.add(wall1)
        innerBuilding.add(wall2)
        innerBuilding.add(wall3)
        innerBuilding.add(wall4)
        grave.add(innerBuilding)

        // Making cubes cast shadows
        innerBuilding.traverseVisible((wall => {
            wall.castShadow = true
            wall.receiveShadow = true
            wall.traverseVisible((cube => {
                cube.castShadow = true
                cube.receiveShadow = true
            }))
        }))

        /**
         *
         * FLOOR OF THE GRAVE
         *
         **/
        innerBuilding.position.set(3,2,3)
        var texture_floor = loader.load("textures/grave_wall.jpg")
        var ground = new THREE.Object3D()

        for(var i=0; i<=22; i+=2){
            for(var j=0; j<=23; j+=2){
                var geometry = new THREE.BoxBufferGeometry(2,2,2);
                var material = new THREE.MeshPhongMaterial({
                    map: texture_floor
                })
                var cube = new THREE.Mesh(geometry, material)
                cube.position.x = i
                cube.position.z = j
                ground.add(cube)
            }
        }

        grave.add(ground)
        ground.castShadow = true
        ground.receiveShadow = true
        ground.position.set(0,0,0)
        ground.traverseVisible((cube =>{
            cube.castShadow = true
            cube.receiveShadow = true
        }))

        pyramid.add(grave)


        /**
         *
         * SARCOPHAGUS
         *
         */

        var sarcophagus = new THREE.Object3D()
        var texture_sarcophagus = loader.load("textures/sarc.jpg")
        texture_sarcophagus.repeat.set( 1, 1 );
        var geometry_sarcophagus = new THREE.BoxBufferGeometry(1,1,1)
        var material_sarcophagus = new THREE.MeshPhongMaterial({
            color: 0x111111,
            map: texture_sarcophagus
        })
        var material_base_sarcophagus = new THREE.MeshPhongMaterial({
            color: 0x111111
        })

        // SARCOPHAGUS Base
        for(var i=0; i<4; i++){
            for(var j=0; j<8; j++){
                if(i!=0){
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
                }else{
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
                }

                sarcophagus.add(sarc)
                sarc.position.set(i,0,j)
            }
        }

        // SARCOPHAGUS  Wall1
        for(var i=0; i<4; i++){
            for(var j=0; j<3; j++){
                if(j!=0){
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
                }else{
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
                }
                sarcophagus.add(sarc)
                sarc.position.set(i,j,0)
            }
        }

        // SARCOPHAGUS Wall2
        for(var i=0; i<8; i++){
            for(var j=0; j<3; j++){
                if(j!=0){
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
                }else{
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
                }
                sarcophagus.add(sarc)
                sarc.position.set(0,j,i)
            }
        }

        // SARCOPHAGUS Wall3
        for(var i=0; i<4; i++){
            for(var j=0; j<3; j++){
                if(j!=0){
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
                }else{
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
                }
                sarcophagus.add(sarc)
                sarc.position.set(i,j,8)
            }
        }


        // SARCOPHAGUS Wall4
        for(var i=0; i<=8; i++){
            for(var j=0; j<3; j++){
                if(j!=0){
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_sarcophagus)
                }else{
                    var sarc = new THREE.Mesh(geometry_sarcophagus, material_base_sarcophagus)
                }
                sarcophagus.add(sarc)
                sarc.position.set(4,j,i)
            }
        }


        grave.add(sarcophagus)
        sarcophagus.position.set(9,1.5,8)


        /**
         *
         * DECORATIONS
         *
         */

        var pharaoh_head_texture = loader.load("textures/pharaoh1test.jpg")
        var monument_texture = loader.load("textures/gravestuff.jpg")
        var pharaoh_geometry = new THREE.BoxBufferGeometry(2,2,2)
        var pharaoh_head_material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            map: pharaoh_head_texture
        })
        var momument_geometry = new THREE.BoxBufferGeometry(3,3,3)
        var monument_material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            map: monument_texture
        })
        var pharaoh_head = new THREE.Mesh(pharaoh_geometry, pharaoh_head_material)
        var monument = new THREE.Mesh(momument_geometry, monument_material)

        sarcophagus.add(pharaoh_head)
        pharaoh_head.position.set(2,4,-4.8)


        /**
         *
         * INNER LIGHTS (with torch)
         *
         */

        var geometry_torch = new THREE.BoxBufferGeometry(0.2,0.2,0.2)
        var material_torch = new THREE.MeshPhongMaterial({
            color: 0x111111
        })

        var offset = 5
        for(var i=0; i<6; i++){
            var torch = new THREE.Mesh(geometry_torch, material_torch)
            sarcophagus.add(torch)
            torch.position.set(2,offset+0.4,-3.9)
            offset += 0.2
        }

        var torch_fire = new THREE.MeshPhongMaterial({
            emissive: 0xfdcf58
        })
        var torch_fire_geom = new THREE.BoxBufferGeometry(0.3,0.3,0.3)
        var torch_light = new THREE.Mesh(torch_fire_geom, torch_fire)
        sarcophagus.add(torch_light)
        torch_light.position.set(2,offset+0.4,-3.85)

        var pointLight1 = new THREE.PointLight(0xf07f13,0.5)
        grave.add(pointLight1)
        pointLight1.position.set(12,8,5)
        pointLight1.castShadow = true

        // var axesHelper = new THREE.AxesHelper( 5 );
        // scene.add( axesHelper );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        document.body.appendChild( stats.domElement );

        // uncomment if you need to draw coordinate axes when building the scene
        //Coordinates.drawAllAxes();

        controls = new THREE.OrbitControls( camera );
        controls.maxPolarAngle = Math.PI * 89/180
        controls.maxDistance = ground_size/2
        controls.addEventListener( 'change', Render );
    }

    function Update() {
        requestAnimationFrame( Update );
        controls.update();
        stats.update();
        if(!showStatic){
            if(animationOn){
                count++
                if(count < 1500) {
                    var translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation(0.01, 0, 0)
                }else{
                    showStatic = true
                }
                small_pyramid.forEach(function (obj){
                    obj.applyMatrix(translation_matrix)
                })
            }

            if(!animationOn){
                count--
                if(count > 0){
                    var translation_matrix = new THREE.Matrix4()
                    translation_matrix.makeTranslation(-0.01, 0, 0) 
                }else{
                    showStatic = true
                }
                small_pyramid.forEach(function (obj){
                    obj.applyMatrix(translation_matrix)
                })
            }
        }
        Render();
    }

    function Render() {
        renderer.render(scene, camera);
    }

    Start();
    Update();

</script>
</body>
</html>